<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>shiny | Adi Sarid - Personal Blog</title>
    <link>/tag/shiny/</link>
      <atom:link href="/tag/shiny/index.xml" rel="self" type="application/rss+xml" />
    <description>shiny</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Adi Sarid, all rights reserved 2020 (c).</copyright><lastBuildDate>Fri, 13 Dec 2019 12:00:00 +0000</lastBuildDate>
    <image>
      <url>/images/icon_hu43b43d5328abc9bf881ba3e56738a448_12724_512x512_fill_lanczos_center_2.png</url>
      <title>shiny</title>
      <link>/tag/shiny/</link>
    </image>
    
    <item>
      <title>Confidence and prediction intervals explained... (with a Shiny app!)</title>
      <link>/post/2019-12-13-confidence_prediction_intervals_explained/</link>
      <pubDate>Fri, 13 Dec 2019 12:00:00 +0000</pubDate>
      <guid>/post/2019-12-13-confidence_prediction_intervals_explained/</guid>
      <description>


&lt;p&gt;This semester I started teaching introduction to statistics and data analysis with R, at Tel-Aviv university.&lt;/p&gt;
&lt;p&gt;I put in a lot of efforts into bringing practical challenges, examples from real life, and a lot of demonstrations of statistical theory with R. This post is an example for how I’ve been using R code (and specifically Shiny apps) to demonstrate statistical theory, concepts and provide intuition.&lt;/p&gt;
&lt;div id=&#34;whats-the-difference-between-confidence-and-prediction-intervals&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;What’s the difference between confidence and prediction intervals?&lt;/h2&gt;
&lt;p&gt;Last week I taught multiple linear regression, and I noticed that students have a hard time comprehending the difference between confidence intervals and prediction intervals. The former being an interval for the model (i.e., interval for the underlying model), and the latter being an interval for a noval observation.&lt;/p&gt;
&lt;p&gt;As the sample size increases, our uncertainty of the model’s parameters decreases, but the uncertainty in the value of a new observation, &lt;span class=&#34;math inline&#34;&gt;\(y_0\)&lt;/span&gt; is associated with variance of &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; (the random variable from which &lt;span class=&#34;math inline&#34;&gt;\(y_0\)&lt;/span&gt; is drawn). Hence, it has a lower bound, based on that variance.&lt;/p&gt;
&lt;p&gt;In R, you can get a prediction or a confidence interval by using either&lt;/p&gt;
&lt;p&gt;&lt;code&gt;predict(object, newdata, interval = &#34;prediction&#34;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Or&lt;/p&gt;
&lt;p&gt;&lt;code&gt;predict(object, newdata, interval = &#34;confidence&#34;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;For a prediction or for a confidence interval, respectively.&lt;/p&gt;
&lt;p&gt;To help me illustrate the differences between the two, I decided to build a small Shiny web app. It shows the differences between confidence intervals, prediction intervals, the regression fit, and the actual (original) model.&lt;/p&gt;
&lt;p&gt;The app is available &lt;a href=&#34;https://sarid.shinyapps.io/intervals_demo/&#34;&gt;here&lt;/a&gt;, and the source code is available on &lt;a href=&#34;https://github.com/adisarid/prediction_confidence_intervals_demo&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;With this app you can choose three types of models to demonstrate. Simple linear regression, and regression with a twist (&lt;span class=&#34;math inline&#34;&gt;\(\log\)&lt;/span&gt; transformation on the &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; or &lt;span class=&#34;math inline&#34;&gt;\(\sin\)&lt;/span&gt; transformation on the &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Linear model &lt;span class=&#34;math inline&#34;&gt;\(y = a + bx + \epsilon\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Log-linear model &lt;span class=&#34;math inline&#34;&gt;\(\log(y)=a+bx+\epsilon\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sine &lt;span class=&#34;math inline&#34;&gt;\(y = a + b\sin(x) + \epsilon\)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All the models are based on simple linear regression (&lt;code&gt;lm&lt;/code&gt; function), for the latter two models with either a &lt;code&gt;log&lt;/code&gt; or &lt;code&gt;sin&lt;/code&gt; transformation.&lt;/p&gt;
&lt;p&gt;The app allows you to play around with various values such as the &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; range, the model’s parameters (&lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt;), the error’s standard deviation (&lt;span class=&#34;math inline&#34;&gt;\(\epsilon\)&lt;/span&gt;), and show or hide any of the following elements, on the chart:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The original function (i.e., the original model)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The sampled points&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The confidence interval&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The prediction interval&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The model’s fit&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Feel free to share the app or the app’s code. As mentioned above, the &lt;strong&gt;source code for the app&lt;/strong&gt; is available here: &lt;a href=&#34;https://github.com/adisarid/prediction_confidence_intervals_demo&#34;&gt;https://github.com/adisarid/prediction_confidence_intervals_demo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here’s an example for what the app’s generating code and output looks like, for a model of the type &lt;span class=&#34;math inline&#34;&gt;\(\log(y) = 1 + \frac{x}{2} + \epsilon\)&lt;/span&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dplyr)
library(tidyr)
library(tibble)
library(ggplot2)

sample_size &amp;lt;- 90
x_range &amp;lt;- c(0, 1.5)
a &amp;lt;- 1
b &amp;lt;- 1.5
sigma &amp;lt;- 0.3

actual_function &amp;lt;- tibble(x = seq(x_range[1], x_range[2], by = 0.01)) %&amp;gt;% 
  mutate(actual_y = exp(a + b*x))

random_sample &amp;lt;- tibble(epsilon_err = rnorm(n = sample_size, 
                                            mean = 0,
                                            sd = sigma),
                        x = runif(n = sample_size,
                                  min = x_range[1],
                                  max = x_range[2])) %&amp;gt;% 
  mutate(sampled_y = exp(a + b*x + epsilon_err))

linear_model &amp;lt;- lm(formula = log(sampled_y) ~ x, data = random_sample)

prediction_i &amp;lt;- predict(object = linear_model,
                         newdata = actual_function,
                         interval = &amp;quot;prediction&amp;quot;) %&amp;gt;% 
  as_tibble() %&amp;gt;% 
  rename_at(vars(lwr,upr), ~paste0(., &amp;quot;_pi&amp;quot;)) %&amp;gt;% 
  mutate_all(exp)

confidence_i &amp;lt;- predict(object = linear_model,
                         newdata = actual_function,
                         interval = &amp;quot;confidence&amp;quot;) %&amp;gt;% 
  as_tibble() %&amp;gt;% 
  rename_at(vars(lwr,upr), ~paste0(., &amp;quot;_ci&amp;quot;)) %&amp;gt;% 
  select(-fit) %&amp;gt;% 
  mutate_all(exp)

intervals &amp;lt;- actual_function %&amp;gt;% 
  bind_cols(prediction_i,
            confidence_i)

ggplot() + 
  geom_line(data = actual_function, aes(x, actual_y, color = &amp;quot;Original Model&amp;quot;), size = 1) + 
  geom_point(data = random_sample, aes(x, sampled_y), alpha = 0.5) + 
  geom_line(data = intervals, 
            aes(x, fit, color = &amp;quot;Regression Fit&amp;quot;), size = 1) + 
  geom_line(data = intervals, 
            aes(x, lwr_pi, color = &amp;quot;Prediction Interval&amp;quot;), 
            linetype = 2, size = 1) +
  geom_line(data = intervals, 
            aes(x, upr_pi, color = &amp;quot;Prediction Interval&amp;quot;), 
            linetype = 2, size = 1) + 
  geom_line(data = intervals, 
            aes(x, lwr_ci, color = &amp;quot;Confidence Interval&amp;quot;), 
            linetype = 2, size = 1) + 
  geom_line(data = intervals, 
            aes(x, upr_ci, color = &amp;quot;Confidence Interval&amp;quot;), 
            linetype = 2, size = 1) + 
  theme_bw() + 
  xlab(&amp;quot;x&amp;quot;) + 
  ylab(&amp;quot;y&amp;quot;) + 
  ggtitle(&amp;quot;Log-linear: Model, Fit, Confidence and Prediction Intervals&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-12-13-confidence_prediction_intervals_explained_files/figure-html/example%20for%20a%20log%20linear%20relationship-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Shiny apps are a great way to illustrate theoretical concepts, to provide intuition, and to let students experiment with parameters and see the outcomes. In this post I demonstrated how a Shiny app can be used to explain the concepts of a regression fit, confidence, and prediction intervals.&lt;/p&gt;
&lt;p&gt;If you used Shiny for interesting educational demonstrations I’d love to hear about it! feel free to share in the comments or message me on twitter &lt;span class=&#34;citation&#34;&gt;@SaridResearch&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Securing Shiny apps with AWS Cognito authentication</title>
      <link>/post/2019-08-10-cognito-shiny-authentication/</link>
      <pubDate>Fri, 30 Aug 2019 12:00:00 +0000</pubDate>
      <guid>/post/2019-08-10-cognito-shiny-authentication/</guid>
      <description>


&lt;div id=&#34;background&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Background&lt;/h2&gt;
&lt;p&gt;Shiny apps are a great way to share information and empower your users. Sometimes you want to make sure that only authenticated and authorized users will be able to view your shiny apps.&lt;/p&gt;
&lt;p&gt;There are a number of ways to make sure only certain users have access to your apps. For example, you can subscribe to the professional plan in shinyapps.io which has this option built-in. You can program the authentication flow internally by yourself, or you just use a 3rd party service such as google firebase, AWS Cognito, Auth0, or others).&lt;/p&gt;
&lt;p&gt;The benefit of using a dedicated service is that you get a lot of features which will be a serious headake to program yourself, such as social logins, two factor authentication, logs, and user blocks on suspicious attempts (or warnings on unauthorized attempts, depending on settings).&lt;/p&gt;
&lt;p&gt;The down side is that it takes some time to implement. In this guide I aim to make the process as simple and painless as possible, using the Amazon Web Service’s authentication solution, called &lt;em&gt;AWS Cognito&lt;/em&gt;. But first, some theory about authentication.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;how-authentication-works&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;How authentication works&lt;/h2&gt;
&lt;p&gt;The logic behind authentication with AWS Cognito (or similar alternatives) is that you direct your users to a login page hosted by AWS, in which the user completes a process which confirms the user’s indentity. For example, by entering an e-mail and password, or by using a social sign-in (i.e., login via gmail, amazon, facebook). Then, once Cognito is finished, the user is redirected to your app with a URL variable which contain a specially issued code (i.e., &lt;code&gt;https://your-app-address/?code=AMAZON_ISSUED_CODE&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Then, you use an http request (i.e., with package &lt;code&gt;httr&lt;/code&gt;) to query the Cognito API with this code, and in return you receive the information behind this code (i.e., the user’s &lt;em&gt;token&lt;/em&gt;, with information such as the name of the user, what is the user’s email, validity of the token, etc.). This &lt;code&gt;httr&lt;/code&gt; query is performed by using a password known only to you (i.e., only your app “knows” this password, this is not the user’s password).&lt;/p&gt;
&lt;p&gt;The code is usable only once, and the token is valid for a limited duration, to minimize the risk that an unauthorized party will hijack the token and re-use it to access your app.&lt;/p&gt;
&lt;p&gt;After authenticating the user, you can authorize the user according to privileges (which you would have to manage within your app, i.e. if the users email is X, then he can view Y).&lt;/p&gt;
&lt;p&gt;This process description was a very simplified, down-to-earth, nutshell description of oauth2. It might be inaccurate, but it will be enough for our goal here which is to actually implement it within a shiny app, integrating to Cognito. If you wish, you can find more information about oauth2 in detail &lt;a href=&#34;https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let’s get to business.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;step-1-define-a-user-pool&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Step 1: Define a user pool&lt;/h2&gt;
&lt;p&gt;This step is actually performed within the AWS Console. Log into your AWS console and find the Cognito service.
Click on “Manage User Pools”, and then create a new user pool. The step-by-step wizard is pretty self explanatory, so I’ll focus on the important things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Make sure that you require a relevant field upon your user sign-up which you can “count on” in order to perform user authorization within your app based on that field later on. I usually check the email address as a required field, and then add logic in my app which maps email addresses to what each user is allowed to view.&lt;/li&gt;
&lt;li&gt;Multi-factor authentication can be “off”, “optional” or “required”. If your app contains sensitive information, then you should consider making it required.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Important!&lt;/strong&gt; in the step where you are asked “Which app clients will have access to this user pool?” click on “Add an app client”. Give your app a name, the deafult options are sufficient so you shouldn’t change anything.&lt;/p&gt;
&lt;p&gt;Make sure you click on “Show Details” after you added your app and document the App client id and the App client secret. You will need them later on to interact with the Cognito API.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/aws_app_info.jpg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Optional&lt;/strong&gt;: right after you add your app and click “next step”, you will have a chance to add functions triggered by the various steps of the authentication flow. If you know what AWS Lambda functions are (and you defined such functions in your account) you can choose to trigger them depending on the authentication flow.&lt;/p&gt;
&lt;p&gt;Complete the wizard and create your user pool.&lt;/p&gt;
&lt;div id=&#34;email-communications&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Email communications&lt;/h3&gt;
&lt;p&gt;You must have the AWS SES (simple email service) configured properly, in order for the registration of new users and “forgot password” flows to work. By default, SES is in sandbox mode, which means you can only register users with pre-verified emails. Defining SES is outside the scope of this guide, but note that you have to open a ticket in the AWS support center, asking for these privilleges.&lt;/p&gt;
&lt;p&gt;Make sure you supply AWS support with a lot of information about how you make sure emails don’t bounce, and about spam prevention. Even though it’s trivial, since this is an internal AWS system using the email service, they made me jump through hoops, untill granting me a 50k daily email cap, which is more than enough for me.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;app-client-settings&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;App client settings&lt;/h3&gt;
&lt;p&gt;Under the “App integration -&amp;gt; App client settings” you need to add the Callback URL of your app (where the user is directed upon login). For example, if your app is going to be hosted on shinyapps.io that would be: &lt;code&gt;https://YOUR_USER_NAME.shinyapps.io/YOUR_APP_NAME&lt;/code&gt;. Your sign-out url can be the same, if you want the app to allow the user to restart the login, or a different page showing that the user has logged out.&lt;/p&gt;
&lt;p&gt;Under OAuth 2.0/“Allowed OAuth Flows” you should check the: &lt;em&gt;Authorization code grant&lt;/em&gt;. This is the authentication flow we are going to use for our shiny app. The “implicit grant” is not as secure, and the “client credentials” is used for machine-to-machine authentication.&lt;/p&gt;
&lt;p&gt;Under “Allowed OAuth Scopes” check the options by which you are going to recognize your users within the shiny app’s logic. I.e., if you are going to show specific data by the user’s email address than make sure you check the “email” under allowed OAuth scopes.&lt;/p&gt;
&lt;p&gt;Set a domain name for your login screen and customize the UI of the login screen if you wish.&lt;/p&gt;
&lt;p&gt;You can see in the following screenshot, that I’m using this authentication with one of my apps hosted in a shinyapps.io domain, under my account.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/aws_app_client_settings.jpg&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;enable-identity-provides-optional&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Enable identity provides (Optional)&lt;/h3&gt;
&lt;p&gt;If you want to offer your users a social login such as Facebook or Google, you would need to issue the proper credentials via google console and facebook. This is a nice addition, but is out of the scope of this guide.&lt;/p&gt;
&lt;p&gt;Finally, we get into the R code part of this post.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;step-2-authorization-code-within-r&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Step 2: Authorization code (within R)&lt;/h2&gt;
&lt;p&gt;Now we need to add logic to our shiny app which will redirect the user to the AWS Cognito login page, and once the user authenticates and redirected to the shiny app, our shiny app will verify the token’s validity.&lt;/p&gt;
&lt;p&gt;Very basically, the Shiny app should read query url variables, and:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;If no variables appear, show a login button to the user (which will redirect to the AWS Cognito login screen with the proper parameters).&lt;/li&gt;
&lt;li&gt;If a url variable called &lt;code&gt;code&lt;/code&gt; appears, our app will read its value, and use AWS Cognito to apply a second layer of verification and identification according to the code (read the token issued by Cognito).&lt;/li&gt;
&lt;li&gt;If the user is logged on, show a “logout” button which will redirect the user into AWS Cognito logout link.&lt;/li&gt;
&lt;/ol&gt;
&lt;div id=&#34;redirect-links-to-loginlogout-screen-authorization-logout-endpoints&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Redirect links to login/logout screen (AUTHORIZATION, LOGOUT Endpoints)&lt;/h3&gt;
&lt;p&gt;There are two “endpoints” (urls) that your users will be redirected to:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;During their login flow into the app, or;&lt;/li&gt;
&lt;li&gt;After they click “logout”.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first is the “AUTHORIZATION Endpoint”. It is a redirection of the client to a url of the following form (I have already put it into a &lt;code&gt;paste0&lt;/code&gt; command, which we will later use in our app).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base_cognito_url &amp;lt;- &amp;quot;https://YOUR_PREEDEFINED_AWS_COGNITO_DOMAIN.amazoncognito.com/&amp;quot;
app_client_id &amp;lt;- &amp;quot;YOUR_APP_CLIENT_ID&amp;quot;
app_client_secret &amp;lt;- &amp;quot;YOUR_APP_CLIENT_SECRET&amp;quot;
redirect_uri &amp;lt;- &amp;quot;https://YOUR_APP/redirect_uri&amp;quot; 
# e.g., if you are using shinyapps.io this would be: 
# https://ACCOUNT_NAME.shinyapps.io/YOUR_APP_NAME

aws_auth_redirect &amp;lt;-
  paste0(
    base_cognito_url,
    &amp;quot;oauth2/authorize?&amp;quot;,
    &amp;quot;response_type=code&amp;amp;&amp;quot;,
    &amp;quot;client_id=&amp;quot;, app_client_id, &amp;quot;&amp;amp;&amp;quot;,
    &amp;quot;redirect_uri=&amp;quot;, redirect_uri, &amp;quot;&amp;amp;&amp;quot;,
    &amp;quot;state=appredirect&amp;quot;
  )

aws_auth_redirect&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;https://YOUR_PREEDEFINED_AWS_COGNITO_DOMAIN.amazoncognito.com/oauth2/authorize?response_type=code&amp;amp;client_id=YOUR_APP_CLIENT_ID&amp;amp;redirect_uri=https://YOUR_APP/redirect_uri&amp;amp;state=appredirect&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also specify the “scopes” (what information should Cognito hold for your next query, email, phone, etc.). If you don’t specify any scopes, all the information available on the user will be provided (see the next section of this post “&lt;strong&gt;Querying Cognito with the grant code&lt;/strong&gt;”).&lt;/p&gt;
&lt;p&gt;The second endpoint is the “LOGOUT Endpoint” which will logout the user. It is important to provide a logout button so that users can safely close your app, without worrying about other users in the same computer abusing their credentials.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;aws_auth_logout &amp;lt;-
  paste0(
    base_cognito_url, &amp;quot;logout?&amp;quot;,
    &amp;quot;client_id=&amp;quot;, app_client_id, &amp;quot;&amp;amp;&amp;quot;,
    &amp;quot;logout_uri=&amp;quot;, redirect_uri
  )

aws_auth_logout&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;https://YOUR_PREEDEFINED_AWS_COGNITO_DOMAIN.amazoncognito.com/logout?client_id=YOUR_APP_CLIENT_ID&amp;amp;logout_uri=https://YOUR_APP/redirect_uri&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once a user has completed the login process (via the authorization endpoint), he will be redirected to your app (the link you provided in the redirect_uri and in the Cognito setup at step 1). If the login is successful, the user will return with a url variable called code, i.e. &lt;code&gt;https://YOUR_APP/redirect_uri?code=####-####-####-####&lt;/code&gt;. The next step will be to make sure that this code is indeed valid, and to check who is the user trying to access behind this code.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;querying-cognito-with-the-grant-code&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Querying Cognito with the grant code&lt;/h3&gt;
&lt;p&gt;This is a crucial part, in which we make sure that the user is indeed valid, and allowed to access your app. We’re going to use the &lt;code&gt;httr&lt;/code&gt; package for that.&lt;/p&gt;
&lt;p&gt;Let’s assume we have already pulled the authorization code from the Shiny app’s url variables (we’re going to show how to do that in step 3).&lt;/p&gt;
&lt;p&gt;We’re going to build a function which gets the code as an argument and provides the user’s information (or an error if the user is not authenticated or there was a different failure). I usually place this code in my &lt;code&gt;global.r&lt;/code&gt; file, which is a part of the shiny app’s bundle (&lt;code&gt;ui.r&lt;/code&gt;, &lt;code&gt;server.r&lt;/code&gt;, &lt;code&gt;global.r&lt;/code&gt;), and is used to define an environment variables and functions which will be availble to the shiny app. You can also place it at the begining of the &lt;code&gt;server.r&lt;/code&gt; if you don’t want a &lt;code&gt;global.r&lt;/code&gt; file. If you are using a single &lt;code&gt;app.r&lt;/code&gt; just put it before the app itself.&lt;/p&gt;
&lt;p&gt;Here is the code that goes into your &lt;code&gt;global.r&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;base_cognito_url &amp;lt;- &amp;quot;https://YOUR_DOMAIN.YOUR_AMAZON_REGION.amazoncognito.com/&amp;quot;
app_client_id &amp;lt;- &amp;quot;YOUR_APP_CLIENT_ID&amp;quot;
app_client_secret &amp;lt;- &amp;quot;YOUR_APP_CLIENT_SECRET&amp;quot;
redirect_uri &amp;lt;- &amp;quot;https://YOUR_APP/redirect_uri&amp;quot;

library(httr)

app &amp;lt;- oauth_app(appname = &amp;quot;my_shiny_app&amp;quot;,
                 key = app_client_id,
                 secret = app_client_secret,
                 redirect_uri = redirect_uri)
cognito &amp;lt;- oauth_endpoint(authorize = &amp;quot;authorize&amp;quot;,
                          access = &amp;quot;token&amp;quot;,
                          base_url = paste0(base_cognito_url, &amp;quot;oauth2&amp;quot;))


retrieve_user_data &amp;lt;- function(user_code){
  
  failed_token &amp;lt;- FALSE
  
  # get the token
  tryCatch({token_res &amp;lt;- oauth2.0_access_token(endpoint = cognito,
                                              app = app,
                                              code = user_code,
                                              user_params = list(client_id = app_client_id,
                                                                 grant_type = &amp;quot;authorization_code&amp;quot;),
                                              use_basic_auth = TRUE)},
           error = function(e){failed_token &amp;lt;&amp;lt;- TRUE})
  
  # check result status, make sure token is valid and that the process did not fail
  if (failed_token) {
    return(NULL)
  }
  
  # The token did not fail, go ahead and use the token to retrieve user information
  user_information &amp;lt;- GET(url = paste0(base_cognito_url, &amp;quot;oauth2/userInfo&amp;quot;), 
                          add_headers(Authorization = paste(&amp;quot;Bearer&amp;quot;, token_res$access_token)))
  
  return(content(user_information))
  
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;step-3-define-your-shiny-apps-server.r-and-ui.r&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Step 3: define your Shiny app’s &lt;code&gt;server.r&lt;/code&gt; and &lt;code&gt;ui.r&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;In our shiny app, we need to pull the code and use the &lt;code&gt;retrieve_user_data&lt;/code&gt; function we’ve just defined as part of our verification of the user. Here is the code we will use for this. This should go into the &lt;code&gt;server.r&lt;/code&gt; file.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library(shiny)
library(shinyjs)

# define a tibble of allwed users (this can also be read from a local file or from a database)
allowed_users &amp;lt;- tibble(
  user_email = c(&amp;quot;user1@example.com&amp;quot;,
                 &amp;quot;user2@example.com&amp;quot;))

function(input, output, session){
   
   # initialize authenticated reactive values ----
   # In addition to these three (auth, name, email)
   # you can add additional reactive values here, if you want them to be based on the user which logged on, e.g. privileges.
   user &amp;lt;- reactiveValues(auth = FALSE, # is the user authenticated or not
                          name = NULL, # user&amp;#39;s name as stored and returned by cognito
                          email = NULL)  # user&amp;#39;s email as stored and returned by cognito
   
   # get the url variables ----
   observe({
        query &amp;lt;- parseQueryString(session$clientData$url_search)
        if (!(&amp;quot;code&amp;quot; %in% names(query))){
            # no code in the url variables means the user hasn&amp;#39;t logged in yet
            showElement(&amp;quot;login&amp;quot;)
        } else {
            current_user &amp;lt;- retrieve_user_data(query$code)
            # if an error occurred during login
            if (is.null(current_user)){
                hideElement(&amp;quot;login&amp;quot;)
                showElement(&amp;quot;login_error_aws_flow&amp;quot;)
                showElement(&amp;quot;submit_sign_out_div&amp;quot;)
                user$auth &amp;lt;- FALSE
            } else {
                # check if user is in allowed user list
                # for more robustness, use stringr::str_to_lower to avoid case sensitivity
                # i.e., (str_to_lower(current_user$email) %in% str_to_lower(allowed_users$user_email))
                if (current_user$email %in% allowed_users$user_email){
                    hideElement(&amp;quot;login&amp;quot;)
                    showElement(&amp;quot;login_confirmed&amp;quot;)
                    showElement(&amp;quot;submit_sign_out_div&amp;quot;)
                    
                    user$auth &amp;lt;- TRUE
                    user$email &amp;lt;- current_user$email
                    user$name &amp;lt;- current_user$name
                    
                    # ==== User is valid, continue prep ====
                    
                    # show the welcome box with user name
                    output$confirmed_login_name &amp;lt;-
                        renderText({
                            paste0(&amp;quot;Hi there!, &amp;quot;,
                                    user$name)
                        })
                    
                    # ==== Put additional login dependent steps here (e.g. db read from source) ====
                    
                    # ADD HERE YOUR REQUIRED LOGIC
                    # I personally like to select the first tab for the user to see, i.e.:
                    showTab(&amp;quot;main_navigation&amp;quot;, &amp;quot;content_tab_id&amp;quot;, select = TRUE) 
                    # (see the next chunk for how this tab is defined in terms of ui elements)
                    
                    # ==== Finish loading and go to tab ====
                    
                } else {
                    # user not allowed. Only show sign-out, perhaps also show a login error message.
                    hideElement(&amp;quot;login&amp;quot;)
                    showElement(&amp;quot;login_error_user&amp;quot;)
                    showElement(&amp;quot;submit_sign_out_div&amp;quot;)
                }
            }
        }
    })
   
   # This is where you will put your actual elements (the server side that is) ----
   # For example:
    
    output$some_plot &amp;lt;- renderPlot({
        # *** THIS IS EXTREMELY IMPORTANT!!! ***
        validate(need(user$auth, &amp;quot;No privileges to watch data. Please contact support.&amp;quot;))
        # since shinyjs is not safe for hiding content, make sure that any information is covered
        # by the validate(...) expression as was specified. 
        # Rendered elements which were not preceded by a validate expression can be viewed in the html code (even if you use hideElement).
        
        # only if user is confirmed the information will render (a plot in this case)
        plot(cars)
    })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The accompanying user interface (&lt;code&gt;ui.r&lt;/code&gt;) will look like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
library(shiny)
library(shinyjs)

fluidPage(
    useShinyjs(), # to enable the show/hide of elements such as login and buttons
    hidden( # this is how the logout button will like:
        div(
            id = &amp;quot;submit_sign_out_div&amp;quot;,
            a(id = &amp;quot;submit_sign_out&amp;quot;,
              &amp;quot;logout&amp;quot;,
              href = aws_auth_logout,
              style = &amp;quot;color: black; 
              -webkit-appearance: button; 
              -moz-appearance: button; 
              appearance: button; 
              text-decoration: none; 
              background:#ff9999; 
              position: absolute; 
              top: 0px; left: 20px; 
              z-index: 10000;
              padding: 5px 10px 5px 10px;&amp;quot;
              )
            )
    ),
    navbarPage(
        &amp;quot;Cognito auth example&amp;quot;,
        id = &amp;quot;main_navigation&amp;quot;,
        tabPanel(
            &amp;quot;identification&amp;quot;,
            value = &amp;quot;login_tab_id&amp;quot;,
            h1(&amp;quot;Login&amp;quot;),
            div(
                id = &amp;quot;login&amp;quot;,
                p(&amp;quot;To login you must identify with a username and password&amp;quot;),
                # This defines a login button which upon click will redirect to the AWS Cognito login page
                a(id = &amp;quot;login_link&amp;quot;,
                  &amp;quot;Click here to login&amp;quot;,
                  href = aws_auth_redirect,
                  style = &amp;quot;color: black;
                  -webkit-appearance: button;
                  -moz-appearance: button;
                  appearance: button;
                  text-decoration: none;
                  background:#95c5ff;
                  padding: 5px 10px 5px 10px;&amp;quot;)
            ),
            hidden(div(
                id = &amp;quot;login_error_aws_flow&amp;quot;,
                p(&amp;quot;An error has occurred.&amp;quot;),
                p(&amp;quot;Please contact support&amp;quot;)
            )),
            hidden(
                div(
                    id = &amp;quot;login_confirmed&amp;quot;,
                    h3(&amp;quot;User confirmed&amp;quot;),
                    fluidRow(
                        textOutput(&amp;quot;confirmed_login_name&amp;quot;)),
                    fluidRow(
                        p(&amp;quot;Use the menu bar to navigate.&amp;quot;),
                        p(
                            &amp;quot;Don&amp;#39;t forget to logout when you want to close the system.&amp;quot;
                        )
                    )
                )
            ),
        ),
        tabPanel(&amp;quot;Your actual content&amp;quot;, 
                 value = &amp;quot;content_tab_id&amp;quot;,
                 fluidRow(plotOutput(&amp;quot;some_plot&amp;quot;)))
    )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;The post contains essential things you need in order to get started with AWS Cognito authentication for your shiny apps.&lt;/p&gt;
&lt;p&gt;You can extend this process to any authentication service (for example, digital ocean has a similar service to Cognito). There are some packages which implement the entire process for other services, like &lt;code&gt;googleAuthR&lt;/code&gt; for a gmail login &lt;a href=&#34;https://code.markedmondson.me/googleAuthR/articles/google-authentication-types.html&#34;&gt;see this link&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you found this post useful, let me know!, either in comments below, or twitter, or email.&lt;/p&gt;
&lt;p&gt;As always, be careful of how you implement this process in your own apps, to make sure there are no security risks or loopholes. Also, DISCLAIMER: The information in this post is free, you can use this however like. Note that it is published with the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>What NOT to do when building a shiny app (lessons learned the hard way)</title>
      <link>/post/2019-07-03-shiny_app_lessons/</link>
      <pubDate>Fri, 19 Jul 2019 12:00:00 +0000</pubDate>
      <guid>/post/2019-07-03-shiny_app_lessons/</guid>
      <description>


&lt;p&gt;I’ve been building R shiny apps for a while now, and ever since I started working with shiny, it has significantly increased the set of services I offer my clients.&lt;/p&gt;
&lt;p&gt;Here’s a documentations of some of the many lessons I learned in previous projects I did. Hopefully, others can avoid them in the future.&lt;/p&gt;
&lt;div id=&#34;background&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Background&lt;/h2&gt;
&lt;p&gt;Shiny is a really great tool that allows data scientists to communicate their analysis in an appealing and an effective way. However, as data scientists we are used to thinking about things a certain way. Our way of thinking, and our practices are different than these of a software developer or a DevOps.&lt;/p&gt;
&lt;p&gt;Here are some of things I learned along the path of my Shiny app developing experiences - some things that you should and should not do.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;dont-skip-the-planning-phase&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Don’t skip the planning phase&lt;/h2&gt;
&lt;p&gt;Do a mockup, research your implementation options.&lt;/p&gt;
&lt;div id=&#34;mockup&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Mockup&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Do a mockup&lt;/strong&gt;, even if it’s just a piece of paper which took you 5 minutes to draw. It will be worth it.&lt;/p&gt;
&lt;p&gt;Shiny is very tempting in the sense that once you understand the concept of reactive programming, you can go from idea to a full app in a few days work. Why invest time in preparing a mockup or planning, when you can just go ahead and do the actual thing?&lt;/p&gt;
&lt;p&gt;My experience tells me that the app is much more successful in capturing the customer’s needs, when he’s a part of the technical planning phase (when you share your dillemas with the client). It sets expectations, frames what you can and can’t (or won’t) do for the customer, and enables you to find solutions together.&lt;/p&gt;
&lt;p&gt;Also, when you’re looking at a mockup (even if it’s just a simple drawing or a non-interactive slide), it helps in the next stages of building the app’s UI.&lt;/p&gt;
&lt;p&gt;Here is an example of how a mockup would look like when I’m drawing it on a piece of paper. Note how I’ve already written down the purpose of some of the elements and their expeted element ids. It helps building the UI when you’re actually looking at one of these.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/img/mockup_draw_example.jpg&#34; alt=&#34;Example for a mockup drawing&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Example for a mockup drawing&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;research&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Research&lt;/h3&gt;
&lt;p&gt;When you encounter a requirement you did not encounter before, and wondering about how to accomplish it, research.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Is there more than a single way to accomplish what you’re trying?&lt;/li&gt;
&lt;li&gt;What are the pros and cons of each method?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, when I needed to show a table and incorporate data intake into the table, I was researching two options, one with the &lt;code&gt;DataTable&lt;/code&gt; package (via the &lt;code&gt;editable=TRUE&lt;/code&gt; argument) and the other is the &lt;code&gt;rhandsontable&lt;/code&gt; package.&lt;/p&gt;
&lt;p&gt;Both provide data editing, eventually I chose &lt;code&gt;randsontable&lt;/code&gt; which had some limitations (e.g., slower rendering than &lt;code&gt;DataTable&lt;/code&gt;, no search box), but provided more features out-of-the-box (e.g., data validation displaying factors as a list, checkboxes, etc.).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;be-sure-you-can-live-up-to-your-promises&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Be sure you can live up to your promises&lt;/h2&gt;
&lt;p&gt;This is more of a broad issue (you can say its true for anything).&lt;/p&gt;
&lt;p&gt;In my case, in the past I promised some clients I’ll provide “realtime” dashboards. However, as it turned out, I was reading from a csv data dump which provided the data with delays going up to 15-30 minutes.&lt;/p&gt;
&lt;p&gt;In most projects I do, 15 minutes and realtime are pretty much equivalent from a practical standpoint, but in a specific project I did recently, I had a client which wanted to check the data as it was changing minute-by-minute.&lt;/p&gt;
&lt;p&gt;This gap in expectations caused some confusion and dissappointment. We eventually learned from this, and in the future, when realtime is a requirement, we will use a better data source (i.e., data base instead of the delayed data dump).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;dont-forget-to-plan-your-budget&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Don’t forget to plan your budget&lt;/h2&gt;
&lt;p&gt;Make sure you consider all the elements you need for the project. Plan the budget accordingly, and understand the ramifications of scaling the app.&lt;/p&gt;
&lt;p&gt;For example, if you’re using shinyapps.io, get familiar with the pricing packages, figure out what will you need to provide a good SLA (relative to the number of users of the app).&lt;/p&gt;
&lt;p&gt;Same goes for other cloud services, e.g., using a data base - how many users? how many connections? size of data base?&lt;/p&gt;
&lt;p&gt;In most cloud providers you can also set up &lt;strong&gt;billing alerts&lt;/strong&gt; which lets you know when something is exceeding a predetermined threshold.&lt;/p&gt;
&lt;p&gt;All of these are very important when you’re building your quote, and obviously when going into production with your App.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;dont-skip-testing-and-staging-on-your-way-to-production&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Don’t skip testing and staging on your way to production&lt;/h2&gt;
&lt;p&gt;In software development there are various levels of environments, starting from your desktop (“local”), through development server, integration, testing, staging/acceptance, and production. See Wikipedia’s &lt;a href=&#34;https://en.wikipedia.org/wiki/Deployment_environment&#34;&gt;Deployment environment&lt;/a&gt; entry.&lt;/p&gt;
&lt;p&gt;When building an app, make sure you go through these steps. Specifically relating to testing, staging, and production). What I found to be particularly useful is to upload the app twice (in two seperate locations/urls):&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Deploy as a beta app (client acceptance/demo) in which I demonstrate additional features and discuss them with the client, before incorporating them into production.&lt;/li&gt;
&lt;li&gt;Deploy as a production/live app.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As you iterate and improve the app, fix bugs, and add new features, you are also at the risk of breaking things. Thus, you should first update the beta app, share the new additions, and let the client experiment with the app. This way you can double check you didn’t break anything else.&lt;/p&gt;
&lt;p&gt;Only when the client authorizes the corrections, redeploy the new app to the production.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;As data scientists using Shiny, we’ve also become software developers. We’re developing not just for ourselves or for other useRs in our community.&lt;/p&gt;
&lt;p&gt;With Shiny we’re building for end-users. We’re building customer facing apps, and we need to keep that in mind. We should make sure that we adopt and use best practices of software development.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Settling class action lawsuits with conjoint analysis and R (&#43;a conjoint shiny app)</title>
      <link>/post/2019-02-03-class-action-conjoint/</link>
      <pubDate>Sun, 03 Feb 2019 12:00:00 +0000</pubDate>
      <guid>/post/2019-02-03-class-action-conjoint/</guid>
      <description>


&lt;p&gt;A few days ago I presented at the 9th Israeli class action lawsuit conference. You’re probably asking yourself what would a data scientist do in a room full of lawyers?&lt;/p&gt;
&lt;p&gt;Apparently, there is a lot to do… Here’s the story: being in market research, we get a lot of lawyers which are faced with class action lawsuits (either suing or being sued) - and they hire us to conduct research and estimate things like the size of the group for the class action, or the total damages applied on the group.&lt;/p&gt;
&lt;p&gt;This time, we did something special. we conducted our own survey, with consumers in the general public in Israel. The goal was to rate various ways of getting compensation (after settling a class action lawsuit).&lt;/p&gt;
&lt;p&gt;For that we used conjoint analysis. Conjoint is where you ask the survey participants a set of questions (five in our case). Each question has a number of alternatives (or packages) to choose from, and these are randomized per respondent. In our case we showed three packages, each package is defined by three parameters relating to how a consumer can get compensation in case of a class action being won:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Push versus pull - do you have to ask for the compensation or would you get the notification/compensation without asking.&lt;/li&gt;
&lt;li&gt;The value of the compensation - tested at 4 levels (25, 50, 75, and 100 ILS)&lt;/li&gt;
&lt;li&gt;The method of delivery - as a complimentary product, a refund at next purchase, bank cheque, or credit card.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The thing about conjoint analysis is that when you diversify enough, you can then run various models to estimate the weight of each parameter, i.e., using logistic regression.&lt;/p&gt;
&lt;p&gt;The data is available in the &lt;a href=&#34;https://github.com/adisarid/class-action-IL-survey&#34;&gt;github repo&lt;/a&gt;, and the specific data is under the data folder.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#library(tidyverse)
class_action_conjoint &amp;lt;- read_csv(&amp;quot;https://raw.githubusercontent.com/adisarid/class-action-IL-survey/master/data/20190130020529-SurveyExport-general_public-conjoint.csv&amp;quot;,
                                  skip = 1,
                                  col_names = 
                                    c(&amp;quot;Response ID&amp;quot;, &amp;quot;Set Number&amp;quot;, &amp;quot;Card Number&amp;quot;, 
                                      &amp;quot;compensation_push_pull&amp;quot;, &amp;quot;compensation_amount_ILS&amp;quot;, &amp;quot;compensation_type&amp;quot;,
                                      &amp;quot;score_selection&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Parsed with column specification:
## cols(
##   `Response ID` = col_double(),
##   `Set Number` = col_double(),
##   `Card Number` = col_double(),
##   compensation_push_pull = col_character(),
##   compensation_amount_ILS = col_double(),
##   compensation_type = col_character(),
##   score_selection = col_double()
## )&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;glimpse(class_action_conjoint)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Rows: 7,020
## Columns: 7
## $ `Response ID`           &amp;lt;dbl&amp;gt; 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,...
## $ `Set Number`            &amp;lt;dbl&amp;gt; 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5...
## $ `Card Number`           &amp;lt;dbl&amp;gt; 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3...
## $ compensation_push_pull  &amp;lt;chr&amp;gt; &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;pull&amp;quot;, &amp;quot;pu...
## $ compensation_amount_ILS &amp;lt;dbl&amp;gt; 75, 50, 25, 100, 25, 100, 75, 100, 50, 25, ...
## $ compensation_type       &amp;lt;chr&amp;gt; &amp;quot;another_product&amp;quot;, &amp;quot;credit_cart&amp;quot;, &amp;quot;bank_che...
## $ score_selection         &amp;lt;dbl&amp;gt; 0, 0, 100, 0, 100, 0, 0, 0, 100, 0, 100, 0,...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;class_action_conjoint %&amp;gt;% count(compensation_push_pull)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 x 2
##   compensation_push_pull     n
##   &amp;lt;chr&amp;gt;                  &amp;lt;int&amp;gt;
## 1 pull                    3516
## 2 push                    3504&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;class_action_conjoint %&amp;gt;% count(compensation_amount_ILS)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 4 x 2
##   compensation_amount_ILS     n
##                     &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
## 1                      25  1759
## 2                      50  1761
## 3                      75  1752
## 4                     100  1748&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;class_action_conjoint %&amp;gt;% count(compensation_type)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5 x 2
##   compensation_type        n
##   &amp;lt;chr&amp;gt;                &amp;lt;int&amp;gt;
## 1 another_product       1391
## 2 bank_cheque           1410
## 3 coupon                1403
## 4 credit_cart           1415
## 5 refund_next_purchase  1401&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see that the different options are balanced (they should be - they were selected randomly) and that the number of observations is &lt;span class=&#34;math inline&#34;&gt;\(7,020\)&lt;/span&gt;. This is because we had &lt;span class=&#34;math inline&#34;&gt;\(n=468\)&lt;/span&gt; respondents answering the conjoint question groups, each selecting best one out of three, with five such random sets (&lt;span class=&#34;math inline&#34;&gt;\(5*3*468=7020\)&lt;/span&gt;).&lt;/p&gt;
&lt;div id=&#34;logistic-regression&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Logistic regression&lt;/h2&gt;
&lt;p&gt;The easiest (and most basic) way to start analyzing the conjoint data is with logistic regression. Note that I’m not endorsing this use of logistic regression in conjoint analysis, because nowadays it has become a standard to compensate for mixed effects (see package &lt;code&gt;lme4&lt;/code&gt;). However, for the purposes of this post, I’m going to carry on with the simple &lt;code&gt;glm&lt;/code&gt; which is sufficiently good for our illustration. In any case, my experience is that the models yield similar results in most cases.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;glm_set &amp;lt;- class_action_conjoint %&amp;gt;% 
  mutate(score_selection = score_selection/100) %&amp;gt;% 
  mutate(compensation_push_pull = factor(compensation_push_pull,
                                         levels = c(&amp;quot;pull&amp;quot;, &amp;quot;push&amp;quot;),
                                         ordered = F),
         compensation_type = factor(compensation_type,
                                    levels = 
                                      c(&amp;quot;another_product&amp;quot;,
                                        &amp;quot;refund_next_purchase&amp;quot;,
                                        &amp;quot;coupon&amp;quot;,
                                        &amp;quot;bank_cheque&amp;quot;,
                                        &amp;quot;credit_cart&amp;quot;),
                                    ordered = F)) %&amp;gt;% 
  select(-`Set Number`, -`Card Number`, -`Response ID`) %&amp;gt;% 
  mutate(compensation_amount_ILS = factor(compensation_amount_ILS, levels = c(25, 50, 75, 100)))

conjoint_glm_model &amp;lt;- glm(data = glm_set %&amp;gt;% 
      select(score_selection, compensation_push_pull, compensation_amount_ILS, compensation_type),
    formula = score_selection ~ .,
    family = binomial())
summary(conjoint_glm_model)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## glm(formula = score_selection ~ ., family = binomial(), data = glm_set %&amp;gt;% 
##     select(score_selection, compensation_push_pull, compensation_amount_ILS, 
##         compensation_type))
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -1.8635  -0.8111  -0.5139   0.8796   2.6557  
## 
## Coefficients:
##                                       Estimate Std. Error z value Pr(&amp;gt;|z|)    
## (Intercept)                           -3.49667    0.11341 -30.832   &amp;lt;2e-16 ***
## compensation_push_pullpush             0.74140    0.05807  12.767   &amp;lt;2e-16 ***
## compensation_amount_ILS50              1.01476    0.09385  10.813   &amp;lt;2e-16 ***
## compensation_amount_ILS75              1.73623    0.09224  18.823   &amp;lt;2e-16 ***
## compensation_amount_ILS100             2.40149    0.09281  25.876   &amp;lt;2e-16 ***
## compensation_typerefund_next_purchase  0.08431    0.10399   0.811    0.418    
## compensation_typecoupon                1.10396    0.09588  11.514   &amp;lt;2e-16 ***
## compensation_typebank_cheque           1.53888    0.09473  16.245   &amp;lt;2e-16 ***
## compensation_typecredit_cart           1.89640    0.09586  19.782   &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 8936.7  on 7019  degrees of freedom
## Residual deviance: 7295.6  on 7011  degrees of freedom
## AIC: 7313.6
## 
## Number of Fisher Scoring iterations: 4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note how most variables (actually all but &lt;code&gt;compensation_typerefund_next_purchase&lt;/code&gt;) are significant and with a positive estimate (i.e., odds ratio &amp;gt; 1). This means means that when a certain variable increases, the probability of choosing the package increases, i.e.:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Passively getting the compensation (“Push”) is better than a required act to get the compensation (“pull”) .&lt;/li&gt;
&lt;li&gt;Any sum of money (50, 75, 100) is better than 25, in an increasing odds ratio.&lt;/li&gt;
&lt;li&gt;Most compensation types (credit card payback, bank cheque, coupon) are significantly better than a complimentary product.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now comes the interesting part: for example, compare the following three packages. Try to guess which one is more attractive:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Parameter&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Package 1&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Package 2&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Package 3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Push/Pull&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Pull&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Pull&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Push&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Return&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Credit&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Refund&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Coupon&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Price&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;25&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;75&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;25&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;It is not that easy to determine between the three. In this situation there is no single strategy which is superior to the others, we can however plot these three packages with the logistic regression response and standard errors. First let’s put them all in a tibble (I also added the best and worst packages).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;package_comparison &amp;lt;- tribble(
  ~package_name, ~compensation_push_pull, ~compensation_amount_ILS, ~compensation_type,
  &amp;quot;pkg1&amp;quot;, &amp;quot;pull&amp;quot;, 25, &amp;quot;credit_cart&amp;quot;,
  &amp;quot;pkg2&amp;quot;, &amp;quot;pull&amp;quot;, 75, &amp;quot;refund_next_purchase&amp;quot;,
  &amp;quot;pkg3&amp;quot;, &amp;quot;push&amp;quot;, 25, &amp;quot;coupon&amp;quot;,
  &amp;quot;worst&amp;quot;, &amp;quot;pull&amp;quot;, 25, &amp;quot;another_product&amp;quot;,
  &amp;quot;best&amp;quot;, &amp;quot;push&amp;quot;, 100, &amp;quot;credit_cart&amp;quot;
) %&amp;gt;% 
  mutate(compensation_amount_ILS = factor(compensation_amount_ILS)) # need to convert to factor - which is how it is modeled in the glm.

predicted_responses &amp;lt;- predict(conjoint_glm_model, newdata = package_comparison, type = &amp;quot;response&amp;quot;, se.fit = T)

# lets join these together

package_responses &amp;lt;- package_comparison %&amp;gt;% 
  mutate(fit = predicted_responses$fit,
         se.fit = predicted_responses$se.fit)

package_responses&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5 x 6
##   package_name compensation_pu~ compensation_am~ compensation_ty~    fit  se.fit
##   &amp;lt;chr&amp;gt;        &amp;lt;chr&amp;gt;            &amp;lt;fct&amp;gt;            &amp;lt;chr&amp;gt;             &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;
## 1 pkg1         pull             25               credit_cart      0.168  0.0129 
## 2 pkg2         pull             75               refund_next_pur~ 0.158  0.0122 
## 3 pkg3         push             25               coupon           0.161  0.0129 
## 4 worst        pull             25               another_product  0.0294 0.00324
## 5 best         push             100              credit_cart      0.824  0.0123&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# P.S. - excuse the &amp;quot;credit_cart&amp;quot; typo (I build the model that way, only then noticed...)

ggplot(package_responses %&amp;gt;% slice(1:3) , aes(x = package_name, y = fit)) + 
  geom_point() +
  geom_errorbar(aes(ymin = fit - se.fit, ymax = fit + se.fit)) + 
  ggtitle(&amp;quot;Package comparison (packages 1-3)&amp;quot;, subtitle = &amp;quot;Error bars represent the SE&amp;quot;) + 
  ylab(&amp;quot;Predicted response (glm logit)&amp;quot;) + 
  xlab(&amp;quot;Package name&amp;quot;) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-03-class-action-conjoint_files/figure-html/compute%20error%20with%20chart-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(package_responses, aes(x = package_name, y = fit)) + 
  geom_point() +
  geom_errorbar(aes(ymin = fit - se.fit, ymax = fit + se.fit)) + 
  ggtitle(&amp;quot;Package comparison (including best and worst packages)&amp;quot;, subtitle = &amp;quot;Error bars represent the SE&amp;quot;) + 
  ylab(&amp;quot;Predicted response (glm logit)&amp;quot;) +
  xlab(&amp;quot;Package name&amp;quot;) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-02-03-class-action-conjoint_files/figure-html/compute%20error%20with%20chart-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We see that the three packages (pkg1, pkg2, and pkg3) are relatively similar, within one standard error from one another. When compared to the worst package they are roughly &lt;span class=&#34;math inline&#34;&gt;\(\sim8\)&lt;/span&gt; times better (via odds ratio), but the best package is &lt;span class=&#34;math inline&#34;&gt;\(\sim5\)&lt;/span&gt; times better than packages 1-3.&lt;/p&gt;
&lt;p&gt;One can use these concepts to illustrate the benefits of each parameter on the different packages, and let the user experience how different features make the packages more or less “attractive”.&lt;/p&gt;
&lt;p&gt;As an experiment, I prepared a nice little shiny app which lets the user experiment with the different features: build two packages and then compare them. You can checkout the code at the &lt;a href=&#34;https://github.com/adisarid/class-action-IL-survey/tree/master/settlement-app/SettlementAttractive&#34;&gt;github repo&lt;/a&gt;, or check out the live app &lt;a href=&#34;https://sarid.shinyapps.io/class-action&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Surveys are a popular tool used in class actions (at least in Israel). They can be used to estimate the tradeoffs between various types of compensation or settlement, for example with the use of conjoint analysis.&lt;/p&gt;
&lt;p&gt;With a glm model one can tell the differences of various packages, and the odds ratio is a way to illustrate to decision makers a comparison of various options (and how much “more attractive” is one package over another).&lt;/p&gt;
&lt;p&gt;A shiny app can be a nice way to illustrate the results of a conjoint analysis, and to let the user experiment with how different features make a specific option better or worse than another option.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
