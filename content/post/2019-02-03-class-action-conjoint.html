---
title: 'Settling class action lawsuits with conjoint analysis and R (+a conjoint shiny app)'
author: "Adi Sarid"
date: 2019-02-03T12:00:00-00:00
categories: ["R"]
tags: ["Conjoint analysis", "Class actions", "shiny"]
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<p>A few days ago I presented at the 9th Israeli class action lawsuit conference. You’re probably asking yourself what would a data scientist do in a room full of lawyers?</p>
<p>Apparently, there is a lot to do… Here’s the story: being in market research, we get a lot of lawyers which are faced with class action lawsuits (either suing or being sued) - and they hire us to conduct research and estimate things like the size of the group for the class action, or the total damages applied on the group.</p>
<p>This time, we did something special. we conducted our own survey, with consumers in the general public in Israel. The goal was to rate various ways of getting compensation (after settling a class action lawsuit).</p>
<p>For that we used conjoint analysis. Conjoint is where you ask the survey participants a set of questions (five in our case). Each question has a number of alternatives (or packages) to choose from, and these are randomized per respondent. In our case we showed three packages, each package is defined by three parameters relating to how a consumer can get compensation in case of a class action being won:</p>
<ol style="list-style-type: decimal">
<li>Push versus pull - do you have to ask for the compensation or would you get the notification/compensation without asking.</li>
<li>The value of the compensation - tested at 4 levels (25, 50, 75, and 100 ILS)</li>
<li>The method of delivery - as a complimentary product, a refund at next purchase, bank cheque, or credit card.</li>
</ol>
<p>The thing about conjoint analysis is that when you diversify enough, you can then run various models to estimate the weight of each parameter, i.e., using logistic regression.</p>
<p>The data is available in the <a href="https://github.com/adisarid/class-action-IL-survey">github repo</a>, and the specific data is under the data folder.</p>
<pre class="r"><code>#library(tidyverse)
class_action_conjoint &lt;- read_csv(&quot;https://raw.githubusercontent.com/adisarid/class-action-IL-survey/master/data/20190130020529-SurveyExport-general_public-conjoint.csv&quot;,
                                  skip = 1,
                                  col_names = 
                                    c(&quot;Response ID&quot;, &quot;Set Number&quot;, &quot;Card Number&quot;, 
                                      &quot;compensation_push_pull&quot;, &quot;compensation_amount_ILS&quot;, &quot;compensation_type&quot;,
                                      &quot;score_selection&quot;))</code></pre>
<pre><code>## Rows: 7020 Columns: 7── Column specification ────────────────────────────────────────────────────────
## Delimiter: &quot;,&quot;
## chr (2): compensation_push_pull, compensation_type
## dbl (5): Response ID, Set Number, Card Number, compensation_amount_ILS, scor...
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<pre class="r"><code>glimpse(class_action_conjoint)</code></pre>
<pre><code>## Rows: 7,020
## Columns: 7
## $ `Response ID`           &lt;dbl&gt; 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10…
## $ `Set Number`            &lt;dbl&gt; 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 1…
## $ `Card Number`           &lt;dbl&gt; 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1…
## $ compensation_push_pull  &lt;chr&gt; &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;pull&quot;, &quot;pull&quot;…
## $ compensation_amount_ILS &lt;dbl&gt; 75, 50, 25, 100, 25, 100, 75, 100, 50, 25, 75,…
## $ compensation_type       &lt;chr&gt; &quot;another_product&quot;, &quot;credit_cart&quot;, &quot;bank_cheque…
## $ score_selection         &lt;dbl&gt; 0, 0, 100, 0, 100, 0, 0, 0, 100, 0, 100, 0, 10…</code></pre>
<pre class="r"><code>class_action_conjoint %&gt;% count(compensation_push_pull)</code></pre>
<pre><code>## # A tibble: 2 × 2
##   compensation_push_pull     n
##   &lt;chr&gt;                  &lt;int&gt;
## 1 pull                    3516
## 2 push                    3504</code></pre>
<pre class="r"><code>class_action_conjoint %&gt;% count(compensation_amount_ILS)</code></pre>
<pre><code>## # A tibble: 4 × 2
##   compensation_amount_ILS     n
##                     &lt;dbl&gt; &lt;int&gt;
## 1                      25  1759
## 2                      50  1761
## 3                      75  1752
## 4                     100  1748</code></pre>
<pre class="r"><code>class_action_conjoint %&gt;% count(compensation_type)</code></pre>
<pre><code>## # A tibble: 5 × 2
##   compensation_type        n
##   &lt;chr&gt;                &lt;int&gt;
## 1 another_product       1391
## 2 bank_cheque           1410
## 3 coupon                1403
## 4 credit_cart           1415
## 5 refund_next_purchase  1401</code></pre>
<p>You can see that the different options are balanced (they should be - they were selected randomly) and that the number of observations is <span class="math inline">\(7,020\)</span>. This is because we had <span class="math inline">\(n=468\)</span> respondents answering the conjoint question groups, each selecting best one out of three, with five such random sets (<span class="math inline">\(5*3*468=7020\)</span>).</p>
<div id="logistic-regression" class="section level2">
<h2>Logistic regression</h2>
<p>The easiest (and most basic) way to start analyzing the conjoint data is with logistic regression. Note that I’m not endorsing this use of logistic regression in conjoint analysis, because nowadays it has become a standard to compensate for mixed effects (see package <code>lme4</code>). However, for the purposes of this post, I’m going to carry on with the simple <code>glm</code> which is sufficiently good for our illustration. In any case, my experience is that the models yield similar results in most cases.</p>
<pre class="r"><code>glm_set &lt;- class_action_conjoint %&gt;% 
  mutate(score_selection = score_selection/100) %&gt;% 
  mutate(compensation_push_pull = factor(compensation_push_pull,
                                         levels = c(&quot;pull&quot;, &quot;push&quot;),
                                         ordered = F),
         compensation_type = factor(compensation_type,
                                    levels = 
                                      c(&quot;another_product&quot;,
                                        &quot;refund_next_purchase&quot;,
                                        &quot;coupon&quot;,
                                        &quot;bank_cheque&quot;,
                                        &quot;credit_cart&quot;),
                                    ordered = F)) %&gt;% 
  select(-`Set Number`, -`Card Number`, -`Response ID`) %&gt;% 
  mutate(compensation_amount_ILS = factor(compensation_amount_ILS, levels = c(25, 50, 75, 100)))

conjoint_glm_model &lt;- glm(data = glm_set %&gt;% 
      select(score_selection, compensation_push_pull, compensation_amount_ILS, compensation_type),
    formula = score_selection ~ .,
    family = binomial())
summary(conjoint_glm_model)</code></pre>
<pre><code>## 
## Call:
## glm(formula = score_selection ~ ., family = binomial(), data = glm_set %&gt;% 
##     select(score_selection, compensation_push_pull, compensation_amount_ILS, 
##         compensation_type))
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -1.8635  -0.8111  -0.5139   0.8796   2.6557  
## 
## Coefficients:
##                                       Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept)                           -3.49667    0.11341 -30.832   &lt;2e-16 ***
## compensation_push_pullpush             0.74140    0.05807  12.767   &lt;2e-16 ***
## compensation_amount_ILS50              1.01476    0.09385  10.813   &lt;2e-16 ***
## compensation_amount_ILS75              1.73623    0.09224  18.823   &lt;2e-16 ***
## compensation_amount_ILS100             2.40149    0.09281  25.876   &lt;2e-16 ***
## compensation_typerefund_next_purchase  0.08431    0.10399   0.811    0.418    
## compensation_typecoupon                1.10396    0.09588  11.514   &lt;2e-16 ***
## compensation_typebank_cheque           1.53888    0.09473  16.245   &lt;2e-16 ***
## compensation_typecredit_cart           1.89640    0.09586  19.782   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 8936.7  on 7019  degrees of freedom
## Residual deviance: 7295.6  on 7011  degrees of freedom
## AIC: 7313.6
## 
## Number of Fisher Scoring iterations: 4</code></pre>
<p>Note how most variables (actually all but <code>compensation_typerefund_next_purchase</code>) are significant and with a positive estimate (i.e., odds ratio &gt; 1). This means means that when a certain variable increases, the probability of choosing the package increases, i.e.:</p>
<ul>
<li>Passively getting the compensation (“Push”) is better than a required act to get the compensation (“pull”) .</li>
<li>Any sum of money (50, 75, 100) is better than 25, in an increasing odds ratio.</li>
<li>Most compensation types (credit card payback, bank cheque, coupon) are significantly better than a complimentary product.</li>
</ul>
<p>Now comes the interesting part: for example, compare the following three packages. Try to guess which one is more attractive:</p>
<table>
<thead>
<tr class="header">
<th align="left">Parameter</th>
<th align="center">Package 1</th>
<th align="center">Package 2</th>
<th align="center">Package 3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Push/Pull</td>
<td align="center">Pull</td>
<td align="center">Pull</td>
<td align="center">Push</td>
</tr>
<tr class="even">
<td align="left">Return</td>
<td align="center">Credit</td>
<td align="center">Refund</td>
<td align="center">Coupon</td>
</tr>
<tr class="odd">
<td align="left">Price</td>
<td align="center">25</td>
<td align="center">75</td>
<td align="center">25</td>
</tr>
</tbody>
</table>
<p>It is not that easy to determine between the three. In this situation there is no single strategy which is superior to the others, we can however plot these three packages with the logistic regression response and standard errors. First let’s put them all in a tibble (I also added the best and worst packages).</p>
<pre class="r"><code>package_comparison &lt;- tribble(
  ~package_name, ~compensation_push_pull, ~compensation_amount_ILS, ~compensation_type,
  &quot;pkg1&quot;, &quot;pull&quot;, 25, &quot;credit_cart&quot;,
  &quot;pkg2&quot;, &quot;pull&quot;, 75, &quot;refund_next_purchase&quot;,
  &quot;pkg3&quot;, &quot;push&quot;, 25, &quot;coupon&quot;,
  &quot;worst&quot;, &quot;pull&quot;, 25, &quot;another_product&quot;,
  &quot;best&quot;, &quot;push&quot;, 100, &quot;credit_cart&quot;
) %&gt;% 
  mutate(compensation_amount_ILS = factor(compensation_amount_ILS)) # need to convert to factor - which is how it is modeled in the glm.

predicted_responses &lt;- predict(conjoint_glm_model, newdata = package_comparison, type = &quot;response&quot;, se.fit = T)

# lets join these together

package_responses &lt;- package_comparison %&gt;% 
  mutate(fit = predicted_responses$fit,
         se.fit = predicted_responses$se.fit)

package_responses</code></pre>
<pre><code>## # A tibble: 5 × 6
##   package_name compensation_push_pull compensation_amou…¹ compe…²    fit  se.fit
##   &lt;chr&gt;        &lt;chr&gt;                  &lt;fct&gt;               &lt;chr&gt;    &lt;dbl&gt;   &lt;dbl&gt;
## 1 pkg1         pull                   25                  credit… 0.168  0.0129 
## 2 pkg2         pull                   75                  refund… 0.158  0.0122 
## 3 pkg3         push                   25                  coupon  0.161  0.0129 
## 4 worst        pull                   25                  anothe… 0.0294 0.00324
## 5 best         push                   100                 credit… 0.824  0.0123 
## # … with abbreviated variable names ¹​compensation_amount_ILS,
## #   ²​compensation_type</code></pre>
<pre class="r"><code># P.S. - excuse the &quot;credit_cart&quot; typo (I build the model that way, only then noticed...)

ggplot(package_responses %&gt;% slice(1:3) , aes(x = package_name, y = fit)) + 
  geom_point() +
  geom_errorbar(aes(ymin = fit - se.fit, ymax = fit + se.fit)) + 
  ggtitle(&quot;Package comparison (packages 1-3)&quot;, subtitle = &quot;Error bars represent the SE&quot;) + 
  ylab(&quot;Predicted response (glm logit)&quot;) + 
  xlab(&quot;Package name&quot;) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1))</code></pre>
<p><img src="/post/2019-02-03-class-action-conjoint_files/figure-html/compute%20error%20with%20chart-1.png" width="672" /></p>
<pre class="r"><code>ggplot(package_responses, aes(x = package_name, y = fit)) + 
  geom_point() +
  geom_errorbar(aes(ymin = fit - se.fit, ymax = fit + se.fit)) + 
  ggtitle(&quot;Package comparison (including best and worst packages)&quot;, subtitle = &quot;Error bars represent the SE&quot;) + 
  ylab(&quot;Predicted response (glm logit)&quot;) +
  xlab(&quot;Package name&quot;) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1))</code></pre>
<p><img src="/post/2019-02-03-class-action-conjoint_files/figure-html/compute%20error%20with%20chart-2.png" width="672" /></p>
<p>We see that the three packages (pkg1, pkg2, and pkg3) are relatively similar, within one standard error from one another. When compared to the worst package they are roughly <span class="math inline">\(\sim8\)</span> times better (via odds ratio), but the best package is <span class="math inline">\(\sim5\)</span> times better than packages 1-3.</p>
<p>One can use these concepts to illustrate the benefits of each parameter on the different packages, and let the user experience how different features make the packages more or less “attractive”.</p>
<p>As an experiment, I prepared a nice little shiny app which lets the user experiment with the different features: build two packages and then compare them. You can checkout the code at the <a href="https://github.com/adisarid/class-action-IL-survey/tree/master/settlement-app/SettlementAttractive">github repo</a>, or check out the live app <a href="https://sarid.shinyapps.io/class-action">here</a>.</p>
</div>
<div id="conclusions" class="section level2">
<h2>Conclusions</h2>
<p>Surveys are a popular tool used in class actions (at least in Israel). They can be used to estimate the tradeoffs between various types of compensation or settlement, for example with the use of conjoint analysis.</p>
<p>With a glm model one can tell the differences of various packages, and the odds ratio is a way to illustrate to decision makers a comparison of various options (and how much “more attractive” is one package over another).</p>
<p>A shiny app can be a nice way to illustrate the results of a conjoint analysis, and to let the user experiment with how different features make a specific option better or worse than another option.</p>
</div>
